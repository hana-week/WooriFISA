def func1(): # 파라미터도 리턴도 없는 함수
    print('func1이라는 함수가 실행됐어요!')

def func2(): # 파라미터는 없고 리턴은 있는 함수
    return 'func1이라는 함수가 실행됐어요!'

# a 는 함수를 작성할 때 파라미터
def func3(a): # 파라미터는 있고 리턴은 없는 함수
    print(f'{a}라는  func1이라는 함수가 실행됐어요!') # 출력된 a 변수 안에 든 값은 파라미터 자리에 입력한 아규먼트(인자)

    # a 는 함수를 작성할 때 파라미터(인자)
def func4(a): # 파라미터는 있고 리턴도 있는 함수
    return f'{a}라는  func4이라는 함수가 실행됐어요!' # 출력된 a 변수 안에 든 값은 파라미터 자리에 입력한 아규먼트(인수)

c = func3('사과') # print가 함수가 실행되고 끝나서

d = func4('사과') # setter

func4({'key':'value'})  # 기본 파이썬에서는 들어가는 아규먼트의 자료형을 강제할 수 없다

# 입력값 자료형 강제 불가
minus('가', '나') # TypeError: unsupported operand type(s) for -: 'str' and 'str'

# 입력값 전달
# 함수의 정의에 따라서, 함수 실행에 필요한 값을 호출할 때, 반드시 전달 해야 합니다
# 입력값을 전달 할 때는 함수에 정의된 파라미터의 개수와 순서를 맞춰서 값을 넣어주면 됩니다.
# 전달은 인터프리터가 알아서 해줍니다.
def minus2(a=3, b=0):   # a=3, b=0 default 값을 넣어주었기 때문
    return a-b

minus2(b=3) # 지정한 디폴트파라메터만 아규먼트를 바꿔서 실행하기도 합니다.

# 입력값 전달
# 함수의 정의에 따라서, 함수 실행에 필요한 값을 호출할 때, 반드시 전달 해야 합니다
# 입력값을 전달 할 때는 함수에 정의된 파라미터의 개수와 순서를 맞춰서 값을 넣어주면 됩니다.
# 전달은 인터프리터가 알아서 해줍니다.
def minus3(a=3, b=0):   # a=3, b=0 default 값을 넣어주었기 때문
    return a-b, a+b # 리턴은 1개만 가능

# 입력값 전달
# 함수의 정의에 따라서, 함수 실행에 필요한 값을 호출할 때, 반드시 전달 해야 합니다
# 입력값을 전달 할 때는 함수에 정의된 파라미터의 개수와 순서를 맞춰서 값을 넣어주면 됩니다.
# 전달은 인터프리터가 알아서 해줍니다.
def minus3(a=3, b=0):   # a=3, b=0 default 값을 넣어주었기 때문
    return (a-b, a+b) # 리턴은 1개만 가능: 보기좋게 표시를 ( ) 해주기도 합니다.

# [1,2,3,4,5] -> [5,4,3,2,1]
# 오늘뭐했어 -> 어했뭐늘오
def fun_reverse(li):
    '''
    docstring (documemt를 적기 위한 string 이라는 의미)
    리스트로 값을 입력받아서 거꾸로 뒤집는 함수
    '''
    print(id(li)) # 메모리주소
    return li[::-1]

temp.append(9).sort() # 원본을 바꿔버림, return은 하지 않음
# 왜? 또 공간 만들어서 메모리에 아주 긴 배열을 저장할까봐....

# chaining을 하다보면 어떤 함수들은 return이 없는데도 신나게 달게 됩니다...
# 그리고 어느 순간 데이터가 사라져버리고, 원본은 훼손되어 있습니다.

def  print1(*args): # 가변인자
    print(args)

def  print2(*args): # 가변인자
    print(*args)

def  print3(**kwargs): # 가변인자 / 파라미터=아규먼트 순서로 받을거야
    print(kwargs)
